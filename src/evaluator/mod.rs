use std::fmt::{ Display, Write };
use std::rc::Rc;
use std::cell::{RefCell, RefMut};
use std::collections::HashMap;

mod built_ins;

use crate::ast::{self, join, Assignable, Expression, InfixOp, Literal, PrefixOp, Statement};

/// An isolated runtime environment for a gabelang program
pub struct GabrEnv {
    var_scopes: Vec<HashMap<String, Object>>,
    built_ins: HashMap<String, Rc<dyn built_ins::BuiltIn>>
}

impl GabrEnv {
    /// Creates a new environment with no variables set and with built_in functions like len
    pub fn new() -> Self {
        let var_scopes = vec![HashMap::new()];
        let built_ins = built_ins::load_built_ins();
        Self { var_scopes, built_ins }
    }

    /// Runs a gabelang program from an ast that must be generated by the gabelang Parser 
    ///
    /// When evaluating a program using eval_program it also creates a new stack frame in order to
    /// accept all variables declared in the program
    ///
    /// This means that if it is called multiple times it will "forget" all variables and functions
    /// declared in previous eval_program calls. To run a statement without creating a new stack
    /// frame look for [Self::eval_statement]
    pub fn eval_program(&mut self, program: &Vec<ast::Statement>) -> Result<GabrValue, String> {
        let mut result = GabrValue::new(ObjectInner::NULL.as_object(), false);
        self.push_scope();
        for statement in program.iter() {
            result = self.eval_statement(statement)?;
            if result.returning {
                self.pop_scope();
                return Ok(result)
            }
        }
        self.pop_scope();
        Ok(result)
    }

    fn create_func(&mut self, name: String, val: ast::Function) {
        let scope = self.var_scopes.last_mut().expect("Tried to create function but no scopes are available in environment");
        scope.insert(name, ObjectInner::FUNCTION(val).as_object());
    }

    fn get_built_in(&self, name: String) -> Option<Rc<dyn built_ins::BuiltIn>> {
        self.built_ins.get(&name).map(|bi| bi.clone())
    }

    fn create_var(&mut self, name: String, val: Object) {
        let scope = self.var_scopes.last_mut().expect("Tried to create variable but no scopes are available in environment");
        scope.insert(name, val);
    }

    fn get_var(&self, name: &str) -> Option<Object> {
        for scope in self.var_scopes.iter().rev() {
            if let Some(val) = scope.get(name) {
                return Some(val.clone());
            }
        }
        None
    }

    fn get_assignable(&mut self, assignable: &Assignable) -> Result<Object, String> {
        match assignable {
            Assignable::Var(var) => self.get_var(&var).ok_or("Could not find variable in any scope".to_string()),
            Assignable::PropIndex { obj, index } => {
                let index = self.eval_expression(index)?;
                let obj = self.get_assignable(obj)?;
                let index: &ObjectInner = &index.inner();
                match index {
                    ObjectInner::NUMBER(num) => {
                        let arr = obj.inner().clone();
                        if let ObjectInner::ARRAY(arr) = arr {
                            Ok(arr[*num as usize].clone())
                        } else {
                            Err("Can not index into non-array with a number".to_string())
                        }
                    },
                    ObjectInner::STRING(prop) => {
                        // If indexing an object by string expect to 
                        let obj = obj.inner().clone();
                        if let ObjectInner::OBJECT(obj) = obj {
                            Ok(obj.get(prop).map(|obj| obj.clone()).unwrap_or(ObjectInner::NULL.as_object()))
                        } else {
                            Err("Can not index into non-object with a string".to_string())
                        }
                    }
                    _ => Err("can not index by non-number and non string value".to_string())
                }
            },
            Assignable::ObjectProp { obj, prop } => {
                let obj = self.get_assignable(obj)?;
                let obj: &ObjectInner = &obj.inner();
                if let ObjectInner::OBJECT(obj) = obj {
                    Ok(obj.get(prop).map(|obj| obj.clone()).ok_or("Property does not exist on this object".to_string())?)
                } else {
                    Err("Can not get property of non-object value".to_string())
                }
            }
        }
    }

    fn set_var(&mut self, name: &str, val: Object) -> Result<(),String> {
        for scope in self.var_scopes.iter_mut().rev() {
            if scope.contains_key(name) {
                scope.insert(name.to_string(), val);
                return Ok(())
            }
        }
        Err("Environment does not contain variable to be altered".to_string())
    }

    fn set_assignable(&mut self, assignable: &Assignable, val: Object) -> Result<(), String> {
        match assignable {
            Assignable::Var(var) => {
                self.set_var(&var, val)
            },
            Assignable::PropIndex { obj, index } => {
                let index = self.eval_expression(index)?;
                let index: &ObjectInner = &index.inner();
                match index {
                    ObjectInner::NUMBER(num) => {
                        let num = *num;
                        let arr = self.get_assignable(obj)?;
                        let arr_mut: &mut ObjectInner = &mut arr.inner();
                        if let ObjectInner::ARRAY(arr) = arr_mut {
                            if num < 0 {
                                Err("Can not index array with negative index".to_string())
                            } else if (num as usize) < arr.len() {
                                arr[num as usize] = val;
                                Ok(())
                            } else if (num as usize) == arr.len() {
                                arr.push(val);
                                Ok(())
                            } else {
                                Err("Can not set array at an index greater than its length".to_string())
                            }
                        } else {
                            Err("Can not index non-array value by a number".to_string())
                        }
                    },
                    ObjectInner::STRING(prop) => {
                        let obj = self.get_assignable(obj)?;
                        let obj_mut: &mut ObjectInner = &mut obj.inner();
                        if let ObjectInner::OBJECT(obj) = obj_mut {
                            obj.insert(prop.clone(), val);
                            Ok(())
                        } else {
                            Err("Can not index non-array value by a number".to_string())
                        }
                    }
                    _ => return Err("Can not index string with non number value".to_string())
                }
            },
            Assignable::ObjectProp { obj, prop } => {
                let obj = self.get_assignable(obj)?;
                let obj_mut: &mut ObjectInner = &mut obj.inner();
                if let ObjectInner::OBJECT(obj) = obj_mut {
                    obj.insert(prop.clone(), val);
                    Ok(())
                } else {
                    Err("Can not get property of non-object value".to_string())
                }
            }
        }
    }

    fn push_scope(&mut self) {
        self.var_scopes.push(HashMap::new());
    }

    fn pop_scope(&mut self) {
        self.var_scopes.pop();
    }

    fn load_params(&mut self, params: Vec<(String, Result<Object, String>)>) -> Result<(), String> {
        let mut err = Ok(());
        params.into_iter().for_each(|(name, val)| {
            match val {
                Ok(val) => self.create_var(name, val),
                Err(e) => err = Err(e),
            }
        });
        // If there was a problem evaluating a parameter return its error
        err?;
        Ok(())
    }

    /// Evaluates a single gabelang program statement generated by the parser in the environment's context
    pub fn eval_statement(&mut self, statement: &Statement) -> Result<GabrValue, String> {
        match statement {
            Statement::Expression(expression) => {
                Ok(GabrValue::new(self.eval_expression(expression)?, true))
            },
            Statement::Let { ident, expression } => {
                let val = self.eval_expression(expression)?;
                self.create_var(ident.clone(), val);
                Ok(GabrValue::new(ObjectInner::NULL.as_object(), false))
            },
            Statement::Assign { assignable, expression } => {
                let val = self.eval_expression(expression)?;
                self.set_assignable(assignable, val)?;
                Ok(GabrValue::new(ObjectInner::NULL.as_object(), false))
            },
            Statement::Return(val) => {
                match val.as_ref() {
                    Some(value) => {
                        Ok(GabrValue::new(self.eval_expression(value)?, true))
                    },
                    None => Ok(GabrValue::new(ObjectInner::NULL.as_object(), true))
                }
            },
            Statement::If { cond, body, r#else } => {
                let condition_result = self.eval_expression(cond)?.inner().is_truthy();
                if condition_result {
                    self.eval_program(body)
                } else {
                    match r#else.as_ref() {
                        Some(else_block) => self.eval_program(else_block),
                        None => Ok(GabrValue::new(ObjectInner::NULL.as_object(), false))
                    }
                }
            },
            Statement::DoWhile { body, cond } => {
                let mut result;
                loop {
                    result = self.eval_program(body)?;
                    if result.returning ||
                    !self.eval_expression(cond)?.inner().is_truthy() {
                        break
                    }
                }
                Ok(result)
            },
            Statement::While { cond, body } => {
                let mut result = GabrValue::new(ObjectInner::NULL.as_object(), false);
                while self.eval_expression(cond)?.inner().is_truthy() {
                    result = self.eval_program(body)?;
                    if result.returning {
                        break;
                    }
                }
                Ok(result)
            },
            Statement::For { init, cond, update, body } => {
                let mut result = GabrValue::new(ObjectInner::NULL.as_object(), false);
                self.push_scope();
                self.eval_statement(init)?;
                while self.eval_expression(cond)?.inner().is_truthy() {
                    result = self.eval_program(body)?;
                    self.eval_statement(update)?;
                    if result.returning {
                        break;
                    }
                }
                self.pop_scope();
                Ok(result)
            }
            Statement::FuncDecl(func) => {
                self.create_func(func.ident.clone(), func.clone());
                Ok(GabrValue::new(ObjectInner::NULL.as_object(), false))
            },
        }
    }

    fn eval_expression(&mut self, expression: &Expression) -> Result<Object, String> {
        match expression {
            Expression::Prefix { op, expression } => {
                self.eval_prefix(*op, expression)
            },
            Expression::Infix { op, left, right } => {
                self.eval_infix(*op, left, right)
            },
            Expression::Group(expression) => {
                self.eval_expression(expression)
            },
            Expression::FuncCall { func, params } => {
                self.eval_function_call(func, params)
            },
            Expression::Assignable(assignable) => {
                self.get_assignable(assignable)
            },
            Expression::Literal(lit) => {
                match lit {
                    Literal::NumberLit(num) => Ok(ObjectInner::NUMBER(num.clone()).as_object()),
                    Literal::StringLit(string) => Ok(ObjectInner::STRING(string.clone()).as_object()),
                    Literal::Bool(bool) => Ok(ObjectInner::BOOL(*bool).as_object()),
                    Literal::ArrayLit(arr) => {
                        // Create an array of evaluated expressions
                        let arr: Vec<Result<Object, String>> = arr.iter().map(|v| self.eval_expression(v)).collect();
                        let mut err = Ok(());
                        arr.iter().for_each(|v| {
                            if let Err(e) = v {
                                *&mut err = Err(e);
                            }
                        });
                        err?;
                        let arr: Vec<Object> = arr.into_iter().map(|v| v.unwrap()).collect();
                        Ok(ObjectInner::ARRAY(arr).as_object())
                    },
                    Literal::ObjectLit(obj) => {
                        // Create an object
                        let fields: Vec<(String, Result<Object, String>)> = obj.iter().map(|(ident, expression)| (ident.clone(), self.eval_expression(expression))).collect();
                        // Check for error in evaluated fields
                        let mut err = Ok(());
                        fields.iter().for_each(|(_, v)| {
                            if let Err(e) = v {
                                *&mut err = Err(e);
                            }
                        });
                        err?;
                        let fields: HashMap<String, Object> = fields.into_iter().map(|(name, val)| {
                            let val = val.unwrap();
                            (name, val)
                        }).collect();
                        Ok(ObjectInner::OBJECT(fields).as_object())
                    }
                }
            }
        }
    }

    fn eval_prefix(&mut self, op: PrefixOp, expression: &Expression) -> Result<Object, String> {
        let expression = self.eval_expression(expression)?;
        match op {
            PrefixOp::Bang => {
                if let ObjectInner::NUMBER(val) = *expression.inner() {
                    if val != 0 {
                        Ok(ObjectInner::NUMBER(0).as_object())
                    } else {
                        Ok(ObjectInner::NUMBER(1).as_object())
                    }
                } else {
                    Err("Can not perform not operation on non numeric expression".to_string())
                }
            },
            PrefixOp::Neg => {
                if let ObjectInner::NUMBER(val) = *expression.inner() {
                    Ok(ObjectInner::NUMBER(-val).as_object())
                } else {
                    Err("Can not perform not operation on non numeric expression".to_string())
                }
            }
        }
    }

    fn eval_infix(&mut self, op: InfixOp, left: &Expression, right: &Expression) -> Result<Object, String> {
        let op1 = self.eval_expression(left)?.inner().clone();
        let op2 = self.eval_expression(right)?.inner().clone();
        let op1 = match op1 {
            ObjectInner::NUMBER(num) => num,
            ObjectInner::BOOL(bool) => bool as i64,
            ObjectInner::STRING(string1) => {
                if let ObjectInner::STRING(string2) = op2 {
                    return Ok(ObjectInner::STRING(string1 + &string2).as_object());
                } else {
                    return Err(format!("Infix Evaluation Failed: can not concat a string with a non string value"))
                }
            }
            _ => return Err(format!("Infix Evaluation Failed: left operand did not evaluate to a number or bool, expression: {:?} evaluated to {:?}", left, op1))
        };
        let op2 = match op2 {
            ObjectInner::NUMBER(num) => num,
            ObjectInner::BOOL(bool) => bool as i64,
            _ => return Err(format!("Infix Evaluation Failed: left operand did not evaluate to a number or bool, expression: {:?} evaluated to {:?}", right, op2))
        };
        let val = match op {
            InfixOp::Add => op1 + op2,
            InfixOp::Sub => op1 - op2,
            InfixOp::Mult => op1 * op2,
            InfixOp::Div => op1 / op2,
            InfixOp::Eq => {
                if op1 == op2 {
                    1
                } else {
                    0
                }
            },
            InfixOp::NotEq => {
                if op1 != op2 {
                    1
                } else {
                    0
                }
            }
            InfixOp::Gt => {
                if op1 > op2 {
                    1
                } else {
                    0
                }
            },
            InfixOp::Lt => {
                if op1 < op2 {
                    1
                } else {
                    0
                }
            }
        };
        Ok(ObjectInner::NUMBER(val).as_object())
    }

    fn eval_function_call(&mut self, func_locator: &Assignable, params: &Vec<Expression>) -> Result<Object, String> {
        // look in all scopes for a function that matches function name
        let func = self.get_assignable(func_locator).ok();
        if let Some(func) = func {
            let func = &mut *func.inner();
            let func = match func {
                ObjectInner::FUNCTION(func) => func.clone(),
                _ => return Err("Can not call non-function value as function".to_string())
            };
            // Create (parameter, value) list
            let params: Vec<(String, Result<Object, String>)> = func.params.iter()
                .map(|param| param.clone())
                .zip(params.iter().map(|param| self.eval_expression(param)))
                .collect();
            // Create new scope for parameters
            self.push_scope();
            self.load_params(params)?;
            // Evaluate the body of the function with the new context
            let result = self.eval_program(&func.body)?;
            // Remove param variables scope
            self.pop_scope();
            // Function call should not automatically be interpretted as return funcCall(param);
            Ok(result.gabr_object)
        } else {
            let func_name = match func_locator {
                Assignable::Var(ident) => ident,
                _ => return Err("Function call failed to evaluate: function could not be found".to_string()),
            };
            if let Some(built_in) = self.get_built_in(func_name.clone()) {
                let params: Vec<(String, Result<Object, String>)> = built_in.get_params().iter()
                    .map(|param| param.clone())
                    .zip(params.iter().map(|param| self.eval_expression(param)))
                    .collect();
                // Create new scope for parameters
                self.push_scope();
                self.load_params(params)?;
                // Evaluate built in function in new context
                let result = built_in.eval(self)?;
                // Remove param variables scope
                self.pop_scope();
                // Function call should not automatically be interpretted as return funcCall(param);
                Ok(result)
            } else {
                Err(format!("Function {} could not be found", func_name))
            }
        }
    }
}

/// A valid value in the gabelang language
///
/// Could be an integer, array, function, object, or NULL type
#[derive(Clone)]
pub struct GabrValue {
    gabr_object: Object,
    returning: bool,
}

impl GabrValue {
    fn new(gabr_object: Object, returning: bool) -> Self {
        Self { gabr_object, returning }
    }

    /// Checks if the current object is not null
    pub fn is_some(&self) -> bool {
        if let ObjectInner::NULL = *self.gabr_object.inner() {
            false
        } else {
            true
        }
    }
}

impl Display for GabrValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.gabr_object)
    }
}

#[derive(Clone, Debug)]
struct Object(Rc<RefCell<ObjectInner>>);

impl Object {
    fn inner(&self) -> RefMut<ObjectInner> {
        self.0.borrow_mut()
    }
}

impl Display for Object {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if Rc::weak_count(&self.0) == 0 {
            let weak = Rc::downgrade(&self.0);
            let res = write!(f, "{}", self.inner());
            drop(weak);
            return res;
        }
        return f.write_str("Cycle");
    }
}

#[derive(Clone, Debug)]
enum ObjectInner {
    NUMBER(i64),
    STRING(String),
    ARRAY(Vec<Object>),
    FUNCTION(ast::Function),
    OBJECT(HashMap<String, Object>),
    BOOL(bool),
    NULL
}

impl ObjectInner {
    fn is_truthy(&self) -> bool {
        match self {
            Self::NUMBER(val) => *val != 0,
            Self::NULL => false,
            Self::BOOL(b) if !*b => false,
            _ => true
        }
    }

    fn as_object(self) -> Object {
        Object(Rc::new(RefCell::new(self)))
    }
}

impl Display for ObjectInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NUMBER(val) => write!(f, "{val}"),
            Self::STRING(string) => f.write_str(string),
            Self::ARRAY(vals) => {
                write!(f, "[{}]", join(vals, ", "))
            },
            Self::OBJECT(obj) => {
                let properties = obj.iter().map(|(key, val)| {
                    let mut output = String::new();
                    write!(output, "\t{key}: {val}").unwrap();
                    output
                }).collect::<Vec<String>>();
                write!(f, "{{\n{}\n}}", join(&properties, "\n"))
            },
            Self::FUNCTION(func) => {
                write!(f, "(Function: {})", func)
            },
            Self::BOOL(bool) => write!(f, "{}", bool),
            Self::NULL => f.write_str("null")
        }
    }
}
